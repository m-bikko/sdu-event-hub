Отлично! Это подробный кейс с интересными функциями. Ваше видение проекта хорошо структурировано и учитывает разные роли пользователей. Давайте объединим кейс и ваше видение в подробное техническое задание (ТЗ) с архитектурой и документацией для ИИ агента.

**Проект: SDU Event Hub**

**1. Введение**

*   **Проблема:** Отсутствие централизованной платформы для информирования студентов SDU о мероприятиях студенческих клубов, покупки билетов и получения уведомлений, что приводит к низкой осведомленности и вовлеченности.
*   **Решение:** Разработка мобильно-ориентированной веб-платформы (SDU Event Hub) с функциями каталога мероприятий, онлайн-покупки билетов, пуш-уведомлений, геймификации (Social GPA, бонусы) и интеграцией с внешними сервисами.
*   **Цель хакатона:** Создание прототипа платформы, демонстрирующего основные функции (каталог, покупка билета, уведомления, авторизация).
*   **Технологии:** Python Flask (backend), MVC, HTML/CSS/JS (frontend), PostgreSQL (database), External APIs (Gemini, Stripe/Kaspi/QR, Telegram Bot API).
*   **Ориентация:** Mobile-first веб-разработка.
*   **Данные:** Использование реальных или реалистичных данных (без mock data).

**2. Архитектура Проекта**

Проект будет реализован с использованием архитектурного паттерна **Model-View-Controller (MVC)** на базе фреймворка **Flask**.

*   **Model (Модель):** Отвечает за данные и бизнес-логику. Включает:
    *   Взаимодействие с базой данных (ORM, например, SQLAlchemy).
    *   Структуры данных (пользователи, клубы, мероприятия, билеты, бронирования, локации, отзывы, транзакции, бонусы, Social GPA, жанры, теги и т.д.).
    *   Логику расчета Social GPA и бонусов.
    *   Логику взаимодействия с внешними API (отправка запросов, обработка ответов).
*   **View (Представление):** Отвечает за пользовательский интерфейс. Включает:
    *   HTML-шаблоны (Jinja2 в Flask).
    *   CSS для стилизации и обеспечения Mobile-first дизайна (например, с использованием Bootstrap или Tailwind CSS).
    *   JavaScript для интерактивности на стороне клиента.
    *   Представления для разных ролей (Admin, Student, Club Head).
*   **Controller (Контроллер):** Отвечает за обработку входящих запросов от пользователя. Включает:
    *   Маршрутизацию URL (определение, какой функции Flask обрабатывать запрос).
    *   Вызов методов Модели для получения или изменения данных.
    *   Выбор соответствующего Представления для отображения результата.
    *   Обработку пользовательского ввода (формы).
    *   Взаимодействие с внешними API по необходимости (например, инициирование платежа, отправка данных в Gemini, отправка сообщений через Telegram API).

**Взаимодействие с внешними API:**

*   **Gemini API:** Интегрируется на уровне **Controller/Model** для обработки запросов чат-бота и формирования ответов.
*   **Payment Gateway (Stripe/Kaspi/QR):** Инициируется из **Controller** при покупке билета, обрабатывается логика подтверждения платежа и вебхуков в **Model/Controller**.
*   **Telegram Bot API:** Используется **Model/Controller** (или отдельным фоновым процессом) для отправки уведомлений, взаимодействуя с данными пользователей из **Model**.

**База Данных:**
Предпочтительно использовать **PostgreSQL** как более надежную и масштабируемую СУБД для продакшена. Для прототипа на хакатоне можно рассмотреть **SQLite** для простоты развертывания, но необходимо учитывать его ограничения.

**Структура Приложения (каталог):**

```
/project_root
|-- app/
|   |-- __init__.py      # Создание экземпляра Flask приложения
|   |-- models.py        # Описание моделей данных (SQLAlchemy)
|   |-- views/           # Контроллеры (request handlers)
|   |   |-- __init__.py
|   |   |-- auth.py      # Аутентификация (login, register)
|   |   |-- admin.py     # Функции для Admin
|   |   |-- student.py   # Функции для Student
|   |   |-- club_head.py # Функции для Club Head
|   |   |-- events.py    # Общие функции для событий (catalog, view event)
|   |   |-- payments.py  # Логика оплаты и вебхуков
|   |   |-- notifications.py # Логика уведомлений
|   |   |-- chatbot.py   # Логика чат-бота
|   |   |-- api/         # Опционально: для REST API эндпоинтов (например, для будущего моб.приложения)
|   |   |   |-- __init__.py
|   |   |   |-- events_api.py
|   |   |   |-- ...
|   |-- templates/       # HTML шаблоны
|   |   |-- layout.html  # Базовый шаблон
|   |   |-- auth/
|   |   |-- admin/
|   |   |-- student/
|   |   |-- club_head/
|   |   |-- events/
|   |   |-- ...
|   |-- static/          # Статические файлы (CSS, JS, картинки)
|   |   |-- css/
|   |   |-- js/
|   |   |-- images/
|   |-- services/        # Вспомогательные сервисы (интеграция API, расчеты)
|   |   |-- __init__.py
|   |   |-- gemini_service.py
|   |   |-- payment_service.py
|   |   |-- telegram_service.py
|   |   |-- social_gpa_calculator.py
|   |-- forms.py         # Формы для обработки ввода (WTForms)
|   |-- config.py        # Настройки приложения
|-- migrations/          # Для управления миграциями базы данных (Flask-Migrate)
|-- venv/                # Виртуальное окружение
|-- requirements.txt     # Зависимости проекта
|-- run.py               # Точка входа для запуска приложения
```

**3. Техническое Задание (ТЗ)**

**3.1. Общие Требования:**

*   Мобильно-ориентированный дизайн (responsive design) с использованием медиа-запросов или CSS фреймворка.
*   Авторизация для студентов SDU (идеально через корпоративную почту, но для хакатона может быть упрощенная форма с привязкой к email/ID).
*   Данные должны быть сохранены в базе данных.
*   Все взаимодействия с пользователем (кроме пушей) происходят через веб-интерфейс.

**3.2. Роли Пользователей и Функции:**

*   **Admin (Администратор)**
    *   **Авторизация:** Специальная форма входа (Login: `admin`, Password: `admin123`).
    *   **Дашборд/Лента:** Обзор активности, статистики, последние события/резервации.
    *   **Управление Пользователями:**
        *   Просмотр списка всех студентов.
        *   Создание учетных записей студентов (начальные данные: ФИО, email, фото, SDU ID - статичные).
        *   Назначение/снятие роли Club Head для существующих студентов.
        *   Просмотр детального профиля любого студента (ФИО, Фото, Social GPA, Бонусы, Членство в клубах, Посещенные мероприятия, Комментарии).
    *   **Управление Клубами:**
        *   Просмотр списка всех клубов.
        *   Редактирование информации о клубе (название, описание, фото, Club Head).
        *   Создание/удаление клубов.
    *   **Управление Локациями:**
        *   Просмотр списка всех локаций (Red Hall, Blue Hall, Кабинеты D-I).
        *   Редактирование информации о локациях (название, вместимость).
    *   **Мониторинг Резерваций Локаций:**
        *   Просмотр календаря с занятостью локаций по времени.
        *   Возможность видеть, какой клуб зарезервировал время и под какое событие (если прикреплено).
    *   **Управление Жанрами и Тегами:**
        *   Просмотр списка предопределенных жанров и тегов.
        *   Возможность добавления/редактирования/удаления жанров и тегов.
    *   **Управление Событиями:**
        *   Просмотр списка всех событий.
        *   Редактирование/удаление любых событий.
        *   Просмотр списка участников каждого мероприятия.
        *   Просмотр комментариев и рейтингов мероприятий.
    *   **Мониторинг Платежей:** Просмотр списка транзакций, статусов оплаты.
    *   **Управление Бонусами/Social GPA:** Возможность корректировки (опционально для хакатона, но полезно).

*   **Student (Студент)**
    *   **Авторизация/Регистрация:** Через email SDU (или упрощенно).
    *   **Лента Событий:**
        *   Список всех предстоящих мероприятий, отсортированный по дате/времени.
        *   Возможность поиска по названию, описанию, клубу.
        *   Фильтры по жанрам, тегам, клубу, локации, дате.
        *   **Рекомендации:** Блок "Рекомендуемые для вас" на основе тегов/жанров мероприятий, которые пользователь посещал ранее или на клубы которых подписан.
    *   **Просмотр События:**
        *   Подробная страница с информацией о мероприятии: название, описание, фото, дата, время, локация, клуб-организатор, жанры, теги, цена билета, количество доступных/проданных билетов.
        *   Список комментариев и средний рейтинг (после завершения события).
        *   Кнопки: "Записаться"/"Купить билет", "Подписаться на клуб", "Добавить в календарь", "Поделиться".
        *   Кнопка "Оставить комментарий/Оценить" (доступна только после посещения события).
    *   **Система Покупки Билетов:**
        *   Процесс покупки билета для платных событий.
        *   Перенаправление на страницу оплаты (Stripe Hosted Checkout или аналог).
        *   После успешной оплаты: отображение электронного билета в профиле с уникальным QR-кодом.
    *   **Профиль:**
        *   Отображение статических данных: ФИО, Фото (загружается при регистрации/первом входе).
        *   Динамические данные: Social GPA, Количество Бонусов.
        *   Список клубов, членом которых является студент.
        *   Список посещенных мероприятий.
        *   Список предстоящих мероприятий (на которые записан/куплен билет).
        *   Список электронных билетов (с QR-кодами).
        *   Настройки уведомлений (вкл/выкл типы уведомлений).
    *   **Подписки на Клубы:** Возможность подписаться на интересующие клубы для получения уведомлений.
    *   **Поиск Клубов:** Просмотр списка всех клубов.
    *   **Чат-бот:** Интерфейс чата для запросов ("Куда сходить?", "Расскажи о клубе таком-то", "Какие события сегодня?"). Интеграция с Gemini API.
    *   **Расписание:** Отображение личного расписания (опционально, может быть просто список мероприятий, на которые студент записан) с возможностью синхронизации с календарем телефона (iCal/Google Calendar link).
    *   **Уведомления:** Получение уведомлений (через Telegram Bot API) о:
        *   Новых мероприятиях от подписанных клубов.
        *   Напоминания о предстоящих мероприятиях (за 24 часа, за 1 час).
        *   Напоминания о клубных собраниях (для членов клуба).
        *   Персональные рекомендации мероприятий.
    *   **Оставить Комментарий/Оценку:** Возможность оставить текстовый комментарий и поставить оценку (1-5) мероприятию, которое посетил.

*   **Club Head (Глава Клуба)**
    *   **Все функции Студента.**
    *   **Профиль Клуба:** Возможность редактировать информацию о клубе, которым он руководит (название, описание, фото).
    *   **Управление Членами Клуба:**
        *   Просмотр списка членов своего клуба.
        *   Поиск и добавление нового студента в клуб (из существующих пользователей платформы).
        *   Удаление студента из клуба.
    *   **Резервация Локаций:**
        *   Страница выбора локации (Red Hall, Blue Hall, Кабинеты D-I).
        *   Отображение календаря или таблицы занятости выбранной локации по дням и часам (каждая ячейка = 1 час).
        *   Свободные слоты (зеленый/белый), занятые слоты (красный) с указанием клуба, который зарезервировал (для других Club Head'ов виден только факт занятости, не кто именно).
        *   Выбор временного интервала и отправка запроса на резервацию.
        *   После успешной резервации: создание "непривязанной" резервации в системе.
        *   **Обязательство:** Привязать резервацию к созданному событию в течение 24 часов, иначе резервация отменяется автоматически (или требует подтверждения админа).
    *   **Создание События:**
        *   Форма для добавления нового мероприятия.
        *   Поля: Название, Описание (с возможностью форматирования), Загрузка фото/постера.
        *   Цена билета: Выбор из предопределенных значений (0 или 500 KZT) или ввод произвольной суммы (если позволено).
        *   Выбор **заранее созданной резервации** локации из списка своих непривязанных резерваций.
        *   Выбор даты и времени (должно соответствовать выбранной резервации).
        *   Выбор Жанра и Тегов (из предопределенного списка).
        *   Выбор Типа События: "Клубное" (для членов клуба, явка обязательна, влияет на Social GPA) или "Общее" (для всех студентов).
        *   Указание максимального количества участников (для контроля продажи билетов/записи).
    *   **Просмотр Участников События:** Список студентов, которые записались/купили билет на мероприятие, организованное его клубом.
    *   **Мониторинг Комментариев и Рейтинга:** Просмотр отзывов и среднего рейтинга мероприятий, организованных клубом.
    *   **Просмотр Статистики Клуба:** Количество мероприятий, общее число посетителей, средний рейтинг мероприятий клуба (влияет на рейтинг клуба).

**3.3. Дополнительные Функции:**

*   **Social GPA:** Числовой показатель активности студента. Увеличивается при посещении мероприятий (особенно клубных собраний, где явка обязательна), организации мероприятий (для Club Head), положительных отзывах, получении бонусов. Снижается при пропуске обязательных клубных собраний. Расчет основан на данных за последние 6 месяцев.
*   **Система Бонусов:** Накопление баллов за посещение мероприятий (10-50 баллов в зависимости от типа события). Отображение текущего баланса бонусов в профиле. (Интеграция с Urbo Coffee как концепт, без реальной технической интеграции на хакатоне, просто отображение "Доступно для обмена: X бонусов на N чашек кофе").
*   **Рейтинг Мероприятий и Клубов:** Средний рейтинг на основе оценок пользователей (за последние 6 месяцев). Отображение топ-рейтингов.
*   **Интеграция с Календарем:** Кнопка "Добавить в календарь" на странице события, генерирующая файл `.ics` или ссылку для Google Calendar.
*   **Система Отзывов:** Возможность оставить комментарий и оценку только для студентов, *посетивших* мероприятие. Модерация комментариев (опционально, может быть функция админа).
*   **Электронный Билет с QR-кодом:** После покупки/записи, в профиле генерируется уникальный QR-код для каждого билета. QR-код содержит информацию о мероприятии, пользователе и уникальный идентификатор билета.
*   **Онлайн-трансляции:** (Для хакатона как концепт или заглушка) На странице мероприятия Red/Blue Hall может быть ссылка на трансляцию (например, YouTube Live, Zoom). Не требует реализации самой трансляции на стороне платформы.
*   **Проверка Билетов (Концепт NFC/QR):** Для хакатона достаточно реализовать логику генерации и отображения QR-кода. Концепт NFC (перенаправление на публичную ссылку с информацией о билете) может быть описан как будущее улучшение. Публичная ссылка для QR/NFC должна показывать *только* минимально необходимую информацию для проверки (статус билета, кому принадлежит).

**3.4. External API Details & Integration Documentation**

Для ИИ агента, которому предстоит реализация, важны детали интеграции.

**3.4.1. Gemini API (Чат-бот)**

*   **Назначение:** Предоставление информации о мероприятиях, клубах, локациях SDU в разговорной форме. Ответы на вопросы типа "Что сейчас происходит?", "Какие мероприятия сегодня?", "Расскажи о клубе ACM", "Где находится Red Hall?".
*   **Ключ API:** Ваш ключ: `AIzaSyA7zgkfPqewfQsGhQi7L8OYXxsiZuOguSU` (нужно хранить безопасно, не в открытом коде).
*   **Интеграция:**
    1.  Установить библиотеку `google-generativeai`.
    2.  Создать сервис-модуль (e.g., `services/gemini_service.py`) для инкапсуляции логики взаимодействия с API.
    3.  Инициализировать модель Gemini (например, `gemini-pro` или `gemini-1.5-flash`).
    4.  Создать эндпоинт во Flask (например, `/chatbot`) для принятия пользовательских запросов от фронтенда (AJAX).
    5.  **Контекст:** Gemini не знает о ваших текущих данных (мероприятия, клубы, их расписания). Перед отправкой запроса в Gemini, бэкенд должен получить релевантные данные из вашей БД (например, список сегодняшних мероприятий, описание клуба) и включить их в *промпт* для Gemini.
        *   Пример: Пользователь спрашивает "Какие мероприятия сегодня?". Бэкенд:
            *   Запрашивает у БД список всех мероприятий на сегодня.
            *   Форматирует этот список (название, время, место) в текстовый вид.
            *   Формирует промпт для Gemini: "Вот список мероприятий, запланированных на сегодня в SDU: [форматированный список]. Пожалуйста, расскажи студенту об этих мероприятиях и порекомендуй что-нибудь."
            *   Отправляет промпт в Gemini.
            *   Возвращает сгенерированный текст пользователю.
    6.  Обработать ответ от Gemini (извлечь текстовый ответ).
    7.  Вернуть ответ фронтенду для отображения в интерфейсе чата.
    8.  Обработать возможные ошибки API.
*   **Документация для ИИ Агента (пример кода):**

```python
# services/gemini_service.py
import google.generativeai as genai
import os # Для безопасного хранения ключа в переменных окружения

# Использовать переменную окружения для API ключа
# В хакатоне можно использовать config.py, но в продакшене - ENV variables
API_KEY = os.environ.get("GEMINI_API_KEY", "AIzaSyA7zgkfPqewfQsGhQi7L8OYXxsiZuOguSU") # Указать ключ или заглушку

genai.configure(api_key=API_KEY)

# Выберите модель, например 'gemini-pro' или 'gemini-1.5-flash'
model = genai.GenerativeModel('gemini-pro')

def ask_gemini(question, context=None):
    """
    Отправляет вопрос в Gemini API, опционально добавляя контекст.

    Args:
        question (str): Вопрос пользователя.
        context (str, optional): Дополнительный контекст из БД (например, список событий). Defaults to None.

    Returns:
        str: Ответ от Gemini или сообщение об ошибке.
    """
    prompt = question
    if context:
        prompt = f"Вот некоторая информация о SDU: {context}\n\nНа основе этой информации (если релевантно) ответь на вопрос: {question}"

    try:
        response = model.generate_content(prompt)
        # Проверка, что ответ содержит текст
        if response and response.text:
             return response.text
        else:
             return "Извините, не могу ответить на этот вопрос сейчас." # Или более специфичное сообщение
    except Exception as e:
        print(f"Error calling Gemini API: {e}")
        return "Извините, произошла ошибка при обработке запроса."

# views/chatbot.py (Пример эндпоинта)
from flask import Blueprint, request, jsonify
from app.services.gemini_service import ask_gemini
from app.models import Event # Пример импорта модели для получения контекста

chatbot_bp = Blueprint('chatbot', __name__)

@chatbot_bp.route('/chatbot', methods=['POST'])
def handle_chatbot_request():
    user_input = request.json.get('message')
    if not user_input:
        return jsonify({"response": "Please provide a message."}), 400

    # Пример получения контекста: список сегодняшних событий
    # В реальном приложении логика получения контекста будет сложнее и зависеть от вопроса
    today_events = Event.get_todays_events() # Пример метода в модели Event
    context_text = "Предстоящие мероприятия сегодня:\n" + "\n".join([f"- {e.name} ({e.time} в {e.location.name})" for e in today_events]) # Форматирование данных

    gemini_response = ask_gemini(user_input, context=context_text)

    return jsonify({"response": gemini_response})

# В app/__init__.py зарегистрировать блюпринт:
# from app.views.chatbot import chatbot_bp
# app.register_blueprint(chatbot_bp)
```

**3.4.2. Система Оплаты (Stripe/Kaspi Pay/QR)**

*   **Назначение:** Обработка онлайн-платежей за билеты.
*   **Выбор:** Для хакатона наиболее универсальным и хорошо документированным является **Stripe**. Kaspi Pay и QR специфичны для Казахстана и могут потребовать отдельных интеграций. Сосредоточимся на процессе через Stripe как демонстрации онлайн-оплаты. В ТЗ укажем Stripe, но иметь в виду, что для SDU в Казахстане *фактически* нужны Kaspi/QR.
*   **Интеграция (Stripe Flow):**
    1.  Установить библиотеку `stripe`.
    2.  Создать аккаунт Stripe (в тестовом режиме). Получить `Publishable key` (для фронтенда) и `Secret key` (для бэкенда).
    3.  На фронтенде: Когда пользователь нажимает "Купить билет", отправить AJAX запрос на бэкенд для создания сессии оплаты.
    4.  На бэкенде (эндпоинт `/create-checkout-session`):
        *   Получить информацию о билете/мероприятии.
        *   Использовать `stripe.checkout.Session.create()` для создания сессии.
        *   Указать `line_items` (описание товара, цена, валюта, количество).
        *   Указать `mode='payment'`.
        *   Указать `success_url` и `cancel_url` (URL на вашем сайте, куда Stripe перенаправит пользователя после оплаты/отмены).
        *   Вернуть ID сессии на фронтенд.
    5.  На фронтенде: Использовать Stripe.js для перенаправления пользователя на хостируемую Stripe страницу оплаты: `stripe.redirectToCheckout({ sessionId: session.id });`.
    6.  **Обработка результата (Вебхук):**
        *   Stripe уведомит ваш сервер об успешной оплате (или других событиях) через вебхуки. Это *критически важно* для надежного подтверждения платежа. Нельзя полагаться только на `success_url`, так как пользователь может закрыть браузер.
        *   Создать эндпоинт `/stripe-webhook` во Flask.
        *   Настроить этот URL в панели управления Stripe как вебхук для событий типа `checkout.session.completed`. Stripe будет отправлять POST запросы на этот URL.
        *   В обработчике вебхука:
            *   Получить сырое тело запроса и подпись Stripe.
            *   Использовать `stripe.Webhook.construct_event()` для безопасной проверки подписи (защита от поддельных запросов).
            *   Проверить тип события (`event.type == 'checkout.session.completed'`).
            *   Получить объект сессии (`session = event.data.object`).
            *   Из объекта сессии получить необходимые метаданные (например, ID пользователя, ID билета/заказа, которые вы могли передать при создании сессии).
            *   Найти соответствующую запись в вашей БД (заказ, билет) и обновить ее статус на "Оплачено".
            *   Сгенерировать уникальный QR-код для билета и связать его с записью в БД.
            *   Отправить уведомление пользователю (например, через Telegram).
            *   Вернуть ответ `200 OK` Stripe.
*   **Kaspi Pay/QR:** Если время позволит или это будет критично, нужно исследовать их API. Возможно, это будет перенаправление на их платежную страницу или генерация QR-кода, который пользователь сканирует в приложении Kaspi. Процесс подтверждения также, скорее всего, через вебхуки или обратные запросы.

*   **Документация для ИИ Агента (пример кода Stripe):**

```python
# services/payment_service.py
import stripe
import os # Для безопасного хранения ключей

# Использовать переменные окружения
stripe.api_key = os.environ.get("STRIPE_SECRET_KEY", "sk_test_...") # Указать тестовый или реальный ключ

def create_checkout_session(event_id, user_id, amount_kzt, description):
    """
    Создает сессию Stripe Checkout.

    Args:
        event_id (int): ID мероприятия.
        user_id (int): ID пользователя.
        amount_kzt (int): Сумма к оплате в тиынах (1 KZT = 100 тиынов). Stripe использует минимальную единицу валюты.
        description (str): Описание товара (билета).

    Returns:
        stripe.checkout.Session: Объект сессии.
    """
    try:
        session = stripe.checkout.Session.create(
            payment_method_types=['card'], # Можно добавить другие методы, если доступны и настроены
            line_items=[{
                'price_data': {
                    'currency': 'kzt',
                    'product_data': {
                        'name': description,
                    },
                    'unit_amount': amount_kzt, # Сумма в тиынах
                },
                'quantity': 1,
            }],
            mode='payment',
            success_url=os.environ.get("BASE_URL", "http://localhost:5000") + '/payment-success?session_id={CHECKOUT_SESSION_ID}', # URL для успеха
            cancel_url=os.environ.get("BASE_URL", "http://localhost:5000") + '/payment-cancel?session_id={CHECKOUT_SESSION_ID}',   # URL для отмены
            # Передача метаданных, которые вернутся в вебхуке
            metadata={
                'event_id': event_id,
                'user_id': user_id,
            },
        )
        return session
    except Exception as e:
        print(f"Error creating Stripe session: {e}")
        return None

# views/payments.py (Пример эндпоинтов)
from flask import Blueprint, request, jsonify, redirect, url_for
from app.services.payment_service import create_checkout_session
from app.models import Ticket, User, Event # Импорт моделей
# Импорт для обработки вебхуков
from app import db # Ваш объект SQLAlchemy
import qrcode # Библиотека для генерации QR

payments_bp = Blueprint('payments', __name__)

# Фронтенд вызывает этот эндпоинт для начала оплаты
@payments_bp.route('/buy-ticket/<int:event_id>', methods=['POST'])
def buy_ticket(event_id):
    # Проверка авторизации пользователя
    if not current_user.is_authenticated: # Пример с Flask-Login
         return jsonify({"error": "Authentication required"}), 401

    event = Event.query.get(event_id)
    if not event or event.price <= 0:
        return jsonify({"error": "Invalid event or event is free"}), 400

    # Сумма в тиынах
    amount_kzt_smallest_unit = int(event.price * 100)

    # Создаем временную запись билета со статусом "в ожидании оплаты"
    # Это нужно, чтобы в вебхуке мы знали, какой билет обновить
    temp_ticket = Ticket(event_id=event.id, user_id=current_user.id, status='pending')
    db.session.add(temp_ticket)
    db.session.commit() # Получаем ID temp_ticket

    session = create_checkout_session(
        event_id=event.id,
        user_id=current_user.id,
        amount_kzt=amount_kzt_smallest_unit,
        description=f"Билет на мероприятие: {event.name}"
    )

    if session:
        # Возвращаем ID сессии на фронтенд
        return jsonify({'sessionId': session.id})
    else:
        # Удаляем временный билет, если сессия не создана
        db.session.delete(temp_ticket)
        db.session.commit()
        return jsonify({'error': 'Could not create payment session'}), 500

# Эти URL-ы указываются в Stripe как success_url и cancel_url
@payments_bp.route('/payment-success')
def payment_success():
    session_id = request.args.get('session_id')
    # Здесь можно показать страницу "Спасибо за покупку!"
    # Реальное обновление статуса билета происходит в вебхуке
    return "<h1>Оплата успешна!</h1><p>Ваш билет скоро появится в профиле.</p>" # Или рендерить шаблон

@payments_bp.route('/payment-cancel')
def payment_cancel():
    session_id = request.args.get('session_id')
     # Можно найти временный билет по session_id (если хранить его) и удалить/пометить отмененным
    return "<h1>Оплата отменена.</h1><p>Вы можете попробовать снова.</p>" # Или рендерить шаблон

# Эндпоинт для Stripe Webhook
@payments_bp.route('/stripe-webhook', methods=['POST'])
def stripe_webhook():
    # Получаем сырое тело запроса и подпись
    payload = request.data
    sig_header = request.headers.get('Stripe-Signature', None)

    # Ваш секрет вебхука из панели Stripe
    webhook_secret = os.environ.get("STRIPE_WEBHOOK_SECRET", "whsec_...") # Хранить безопасно!

    try:
        event = stripe.Webhook.construct_event(
            payload, sig_header, webhook_secret
        )
    except ValueError as e:
        # Invalid payload
        return 'Invalid payload', 400
    except stripe.error.SignatureVerificationError as e:
        # Invalid signature
        return 'Invalid signature', 400

    # Handle the checkout.session.completed event
    if event['type'] == 'checkout.session.completed':
        session = event['data']['object']

        # Извлекаем метаданные, которые мы добавили при создании сессии
        user_id = session['metadata'].get('user_id')
        event_id = session['metadata'].get('event_id')

        # Ищем соответствующий временный билет или создаем новый, если нужно
        # (логика может отличаться в зависимости от того, как вы управляете билетами до оплаты)
        # Предполагаем, что мы обновляем временный билет по user_id и event_id
        ticket = Ticket.query.filter_by(user_id=user_id, event_id=event_id, status='pending').first()

        if ticket:
            # Подтверждаем билет
            ticket.status = 'paid'
            # Генерируем и сохраняем QR-код
            qr_data = f"ticket:{ticket.id}" # Уникальные данные для QR
            qr = qrcode.make(qr_data)
            # Сохраняем QR-код в файл или Blob в БД
            # Для хакатона можно сохранить в static/qr_codes и сохранить путь в БД
            qr_filename = f"qr_{ticket.id}.png"
            qr_path = os.path.join('app', 'static', 'qr_codes', qr_filename) # Путь для сохранения
            os.makedirs(os.path.dirname(qr_path), exist_ok=True) # Убедимся, что директория существует
            qr.save(qr_path)
            ticket.qr_code_path = f'/static/qr_codes/{qr_filename}' # Путь для отображения

            db.session.commit()

            # Отправить уведомление пользователю через Telegram (используя Telegram Bot API)
            # notification_service.send_ticket_confirmation(user_id, event.name, ticket.qr_code_path)

            print(f"Payment successful and ticket created for user {user_id}, event {event_id}")
        else:
            print(f"Warning: Received webhook for session {session.id} but could not find pending ticket.")

    # Возвращаем ответ, что событие обработано
    return 'OK', 200

# В app/__init__.py зарегистрировать блюпринты:
# from app.views.payments import payments_bp
# app.register_blueprint(payments_bp)
```

**3.4.3. Telegram Bot API (Push Уведомления)**

*   **Назначение:** Отправка асинхронных push-уведомлений пользователям.
*   **Интеграция:**
    1.  Создать Telegram бота через BotFather и получить API токен.
    2.  Установить библиотеку `python-telegram-bot`.
    3.  **Связывание аккаунта SDU Event Hub и Telegram:**
        *   В профиле пользователя на платформе SDU Event Hub добавить кнопку "Подключить Telegram".
        *   При нажатии генерировать уникальный временный код (например, UUID).
        *   Показать пользователю инструкцию: "Напишите нашему боту @YourSDUEventBot и отправьте код: `ВАШ_УНИКАЛЬНЫЙ_КОД`".
        *   Создать обработчик команд в Telegram боте (`/start` или просто текстовых сообщений).
        *   Когда бот получает сообщение, проверить, является ли текст уникальным кодом.
        *   Если код совпадает с кодом в БД (связанным с ожидающим пользователем), получить `chat_id` пользователя из объекта сообщения Telegram.
        *   Сохранить этот `chat_id` в БД в записи пользователя SDU Event Hub. Пометить код как использованный или удалить.
        *   Отправить пользователю в Telegram подтверждение: "Ваш аккаунт успешно связан!".
    4.  **Отправка уведомлений:**
        *   В местах логики приложения, где требуется отправить уведомление (создание нового события от подписанного клуба, напоминание по таймеру, рекомендация), получить `chat_id` пользователя из БД.
        *   Использовать метод `bot.send_message(chat_id, text)` из библиотеки `python-telegram-bot`.
    5.  **Фоновые задачи:** Для напоминаний по таймеру (за 24 часа, за 1 час) потребуется система планирования задач (например, Celery с брокером сообщений типа Redis или RabbitMQ), которая будет периодически проверять предстоящие события и отправлять уведомления через сервис Telegram.
*   **Документация для ИИ Агента (пример кода):**

```python
# services/telegram_service.py
import telegram
import os
# Для фоновых задач может потребоваться Celery, но для хакатона можно обойтись простым скриптом/функцией, запускаемой по расписанию (если нет возможности поднять брокер)

# Использовать переменную окружения для токена бота
TELEGRAM_BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "YOUR_BOT_TOKEN") # Указать токен бота
bot = telegram.Bot(token=TELEGRAM_BOT_TOKEN)

def send_notification(chat_id, text):
    """
    Отправляет текстовое сообщение пользователю в Telegram.

    Args:
        chat_id (str): ID чата пользователя в Telegram.
        text (str): Текст сообщения.
    """
    try:
        bot.send_message(chat_id=chat_id, text=text)
        print(f"Notification sent to chat_id {chat_id}")
    except telegram.Error as e:
        print(f"Error sending Telegram message to chat_id {chat_id}: {e}")
        # Обработать ошибки, например, пользователь заблокировал бота

# models.py (Добавить поле для chat_id пользователя)
# class User(...):
#    ...
#    telegram_chat_id = db.Column(db.String(255), unique=True, nullable=True)
#    telegram_connect_code = db.Column(db.String(255), unique=True, nullable=True) # Для временного кода

# views/student.py (Пример эндпоинта для генерации кода связи)
# @student_bp.route('/profile/link-telegram', methods=['POST'])
# @login_required
# def link_telegram():
#     # Генерация уникального кода
#     import uuid
#     link_code = str(uuid.uuid4())
#     current_user.telegram_connect_code = link_code
#     db.session.commit()
#     return jsonify({"code": link_code, "bot_username": "YourSDUEventBot"}) # Имя бота

# views/notifications.py (Пример функции отправки напоминаний, вызываемой по расписанию)
# from app.models import Event, User
# from app.services.telegram_service import send_notification
# from datetime import datetime, timedelta

# def send_reminders():
#    # Напоминание за 24 часа
#    time_24h_from_now = datetime.utcnow() + timedelta(hours=24)
#    time_25h_from_now = datetime.utcnow() + timedelta(hours=25) # Избегаем дублирования
#    events_24h = Event.query.filter(
#        Event.date_time > time_24h_from_now,
#        Event.date_time <= time_25h_from_now
#    ).all()
#    for event in events_24h:
#        for attendance in event.attendances: # Или ticket.user
#            if attendance.user.telegram_chat_id:
#                message = f"Напоминание! Мероприятие '{event.name}' состоится завтра в {event.date_time.strftime('%H:%M')} в {event.location.name}."
#                send_notification(attendance.user.telegram_chat_id, message)

#    # Напоминание за 1 час (аналогично)
#    # Логика отправки рекомендаций или уведомлений о новых событиях по подписке аналогична,
#    # вызывается при создании нового события или при периодической проверке интересов.

# Этот код send_reminders должен быть запущен планировщиком (например, crontab, APScheduler или Celery Beat)
```

**3.5. Модель Данных (Концептуальная)**

*   `User`: id, sdu_id, first_name, last_name, email, password_hash, role ('admin', 'student', 'club_head'), photo_url, social_gpa, bonus_points, telegram_chat_id, telegram_connect_code.
*   `Club`: id, name, description, photo_url, head_user_id (FK to User), rating.
*   `ClubMembership`: user_id (FK to User), club_id (FK to Club), is_head (boolean, дублирует head_user_id, опционально).
*   `Location`: id, name, capacity_min, capacity_max.
*   `Genre`: id, name.
*   `Tag`: id, name.
*   `Event`: id, name, description, photo_url, club_id (FK to Club), location_id (FK to Location), date_time, price (decimal), max_attendees, type ('club', 'general'), rating, created_at, booking_id (FK to Booking, опционально, ссылка на резервацию).
*   `EventGenre`: event_id (FK to Event), genre_id (FK to Genre). (Many-to-Many)
*   `EventTag`: event_id (FK to Event), tag_id (FK to Tag). (Many-to-Many)
*   `Booking`: id, location_id (FK to Location), club_id (FK to Club), start_time, end_time, status ('pending', 'confirmed', 'cancelled'), event_id (FK to Event, опционально, для привязки), created_at, created_by_user_id (FK to User).
*   `Ticket`: id, event_id (FK to Event), user_id (FK to User), status ('pending', 'paid', 'attended', 'absent', 'cancelled'), qr_code_data (или path к файлу), purchase_time. (Может быть одна запись и для бесплатных "записей").
*   `Attendance`: id, ticket_id (FK to Ticket), checkin_time. (Запись о фактическом посещении для Social GPA)
*   `Review`: id, event_id (FK to Event), user_id (FK to User), rating (int 1-5), comment (text), created_at. (Только для attended tickets)
*   `UserBonusTransaction`: id, user_id (FK to User), points_amount (int), type ('attendance', 'redemption', ...), related_event_id (FK to Event, опционально), created_at.
*   `ClubSubscription`: user_id (FK to User), club_id (FK to Club), subscribed_at. (Для уведомлений о новых событиях клуба)

**3.6. Non-Functional Requirements:**

*   **Производительность:** Время загрузки страниц должно быть минимальным. API запросы (особенно к внешним сервисам) должны обрабатываться асинхронно, если это возможно, или с обработкой тайм-аутов.
*   **Безопасность:** Защита от SQL-инъекций, XSS. Безопасное хранение паролей (хеширование). Защита секретных ключей API. Обработка платежей через безопасные шлюзы (Stripe). Проверка прав доступа на каждом эндпоинте.
*   **Usability:** Интуитивно понятный интерфейс, оптимизированный для мобильных устройств. Четкий процесс регистрации, поиска, записи/покупки билета.
*   **Надежность:** Обработка ошибок при взаимодействии с внешними API. Резервное копирование данных (на этапе продакшена).
*   **Масштабируемость:** Архитектура MVC и использование PostgreSQL закладывают основу для масштабирования (разделение слоев, возможность горизонтального масштабирования БД).

**4. Ожидаемый Результат для Хакатона (Прототип)**

Рабочий прототип веб-приложения, демонстрирующий:

1.  **Авторизация:** Вход для Admin и Student (с возможностью создания аккаунтов Admin'ом или упрощенной регистрацией).
2.  **Каталог мероприятий:** Отображение списка мероприятий с базовой информацией, возможностью просмотра деталей события. Фильтрация по дате и клубу.
3.  **Просмотр события:** Страница с основной информацией о мероприятии.
4.  **Система покупки билетов:**
    *   Процесс "Записаться" (для бесплатных) или "Купить билет" (для платных).
    *   Интеграция со Stripe (тестовый режим) для обработки оплаты.
    *   После оплаты: отображение факта покупки/записи в профиле пользователя (возможно, без генерации QR на этом этапе или с заглушкой).
    *   Обработка вебхука Stripe для подтверждения платежа.
5.  **Профиль Студента:** Отображение посещенных/предстоящих событий, Social GPA и Бонусов (могут быть статичные или базовый расчет). Отображение билетов/записей.
6.  **Пуш-уведомления:** Реализация отправки тестового уведомления через Telegram (например, при записи на событие или вручную через админку). Требуется связать аккаунт пользователя с Telegram chat_id.
7.  **Резервация локаций (для Club Head):** Интерфейс просмотра календаря занятости и создания базовой резервации.

**5. Дополнительные Идеи и Оптимизации (Для будущего или как "плюшки" на хакатоне)**

*   **Проверка Билетов (QR Scanner):** Разработать отдельный интерфейс (возможно, просто веб-страницу, доступную по логину) для волонтеров/организаторов, который позволяет сканировать QR-код на билете студента с телефона и проверять его статус в системе.
*   **Автоматический расчет Social GPA и Бонусов:** Разработать более сложную логику расчета Social GPA на основе посещений (учитывая тип события, обязательность) и бонусов.
*   **Визуализация Social GPA:** Красивые графики или прогресс-бары в профиле.
*   **Рекомендации:** Использование более продвинутых алгоритмов рекомендаций (например, на основе посещенных событий другими пользователями со схожими интересами).
*   **Интеграция с SDU Systems:** Если возможно, интеграция с официальной системой для автоматической регистрации студентов или получения расписания занятий.
*   **Gamification Расширение:** Добавить бейджи за достижения (например, "Первый посетитель", "Самый активный в сентябре", "Фанат Клуба X").
*   **Админка с аналитикой:** Детальные отчеты для админа и глав клубов (популярность мероприятий, демография посетителей, активность клубов).
*   **Система модерации комментариев.**

**6. Структура Документации и Запрос для ИИ Агента**

Для ИИ агента необходимо предоставить четко структурированные инструкции. Следующий текст предназначен для него:

```
---START_OF_AI_AGENT_INSTRUCTIONS---

**Проект: SDU Event Hub - Web Application**

**Цель:** Разработать мобильно-ориентированный веб-прототип платформы для управления мероприятиями студенческих клубов в SDU.

**Технологический Стек:**
*   Backend: Python Flask
*   Архитектура: MVC
*   База данных: PostgreSQL (предпочтительно, или SQLite для простоты прототипа)
*   Frontend: HTML, CSS (Mobile-first, Responsive Design), JavaScript
*   Внешние API:
    *   Gemini API (для чат-бота)
    *   Payment Gateway (Stripe для прототипа)
    *   Telegram Bot API (для пуш-уведомлений)

**Данные:**
*   Не использовать моковые (mock) данные. Данные должны храниться в БД.
*   Необходимо предусмотреть создание начальных данных (пользователи, клубы, локации, жанры, теги) либо через скрипты, либо через админ-панель.

**Пользовательские Роли:** Admin, Student, Club Head.

**Ключевые Функции для Прототипа:**

1.  **Авторизация:**
    *   Вход для Admin (login: admin, password: admin123).
    *   Вход для Student (упрощенная форма или через email).
2.  **Каталог Мероприятий (для всех ролей):**
    *   Список предстоящих событий.
    *   Просмотр детальной информации о событии.
    *   Базовые фильтры (дата, клуб).
3.  **Профиль Пользователя (Student/Club Head):**
    *   Отображение базовой информации.
    *   Отображение списка предстоящих событий, на которые записан.
    *   Отображение Social GPA и Бонусов (можно статично или с базовым расчетом).
4.  **Система Покупки Билетов (для Student):**
    *   Кнопка "Записаться" (для бесплатных) / "Купить билет" (для платных).
    *   Интеграция со Stripe (тестовый режим): перенаправление на Stripe Checkout, обработка вебхука для подтверждения оплаты.
    *   Сохранение факта записи/покупки билета в БД.
5.  **Пуш-уведомления (для Student):**
    *   Механизм связывания аккаунта с Telegram (получение chat_id).
    *   Отправка тестового уведомления через Telegram Bot API при определенном действии (например, запись на событие).
6.  **Создание Событий (для Club Head):**
    *   Базовая форма создания события (название, описание, дата/время, локация, цена, клуб).
    *   Привязка к локации (можно без сложной логики резервации на этом этапе, просто выбор из списка).
7.  **Чат-бот (для Student):**
    *   Интерфейс чата.
    *   Базовая интеграция с Gemini API для ответа на простые вопросы о событиях/клубах (используя контекст из БД).

**Архитектурные Принципы:**

*   Придерживаться паттерна MVC.
*   Разделение кода на модули (views, models, services, templates, static).
*   Использование SQLAlchemy для работы с БД.

**Детали API Интеграций (Смотри разделы 3.4.1, 3.4.2, 3.4.3 ТЗ):**
*   Предоставлены примеры кода и шаги интеграции для Gemini, Stripe (как пример платежной системы), Telegram Bot API.
*   Ключи API должны быть настроены через переменные окружения или конфигурационный файл.

**Mobile-First Design:**
*   Макеты и стили должны быть в первую очередь разработаны для мобильных устройств (узкие экраны), затем адаптированы для больших экранов.
*   Использовать гибкие макеты (flexbox, grid) и медиа-запросы.

**Задачи для ИИ Агента:**

1.  **Проектирование Базы Данных:** Создать SQL схему (или SQLAlchemy модели) на основе описанной концептуальной модели данных (раздел 3.5).
2.  **Структура Проекта:** Создать файловую структуру проекта Flask согласно описанию (раздел 2).
3.  **Реализация Моделей:** Написать код моделей SQLAlchemy для всех ключевых сущностей (User, Club, Event, Ticket, Location, Genre, Tag, Booking, Review, etc.) со связями.
4.  **Реализация Контроллеров (Views):** Создать файлы во `views/` с базовой маршрутизацией (@app.route или Blueprints) для основных страниц и API эндпоинтов, описанных в "Ключевых Функциях для Прототипа".
5.  **Реализация Представлений (Templates):** Создать базовые HTML шаблоны (`templates/`) для страниц (layout, login, catalog, event_detail, profile, admin_dashboard, create_event, chatbot_interface) с учетом mobile-first дизайна. Использовать Jinja2.
6.  **Реализация Статических Файлов:** Базовая структура CSS/JS для responsive дизайна.
7.  **Интеграция с API:**
    *   Написать код в `services/` для взаимодействия с Gemini, Stripe, Telegram API на основе предоставленных примеров и инструкций.
    *   Интегрировать вызовы этих сервисов в соответствующие контроллеры (например, вызов Gemini в `/chatbot`, вызов Stripe при покупке билета, вызов Telegram при создании записи).
    *   Реализовать эндпоинт для Stripe Webhook (`/stripe-webhook`).
8.  **Настройка Приложения:** Создать базовый `config.py` и `__init__.py` для инициализации Flask, SQLAlchemy, регистрации Blueprints.
9.  **Базовые Функции Ролей:** Реализовать логику авторизации и разделения доступа (хотя бы базовое isAdmin/isClubHead).
10. **Начальные Данные:** Предусмотреть (например, в отдельном скрипте `init_db.py`) создание базовых записей для Admin, нескольких клубов, локаций, жанров, тегов для демонстрации.

**Ограничения Прототипа (для хакатона):**

*   Не все функции из полного ТЗ могут быть реализованы. Фокус на "Ключевых Функциях".
*   Логика Social GPA и Бонусов может быть упрощена (например, просто увеличиваться на фиксированное значение при посещении).
*   Система резервации локаций для Club Head может быть упрощена (просто выбор локации без сложной проверки занятости или календаря).
*   Проверка билетов (сканер QR/NFC) не является обязательной для прототипа.
*   Онлайн-трансляции только как заглушка (ссылка).

**Ожидаемый Формат Вывода:**
Предоставить структуру проекта с файлами кода для каждой части (models, views, services, templates, static), SQL схему БД, инструкции по настройке и запуску. Код должен быть на Python (Flask).

---END_OF_AI_AGENT_INSTRUCTIONS---

```

**7. Заключение**

Предложенное ТЗ охватывает все ключевые требования кейса и ваше видение, структурирует их по ролям и функциям, предлагает архитектуру и предоставляет детали для интеграции с внешними API. Учитывая, что это хакатон, фокус должен быть на реализации "Ключевых Функций", а остальные рассматривать как улучшения или будущие задачи. Mobile-first подход потребует внимания к фронтенду, а отсутствие моковых данных — к процессу инициализации БД.

Этот подробный документ должен предоставить ИИ агенту все необходимые данные для генерации структуры проекта и начального кода. Удачи на хакатоне!